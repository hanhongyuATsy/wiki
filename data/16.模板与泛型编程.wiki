++ 16.模板与泛型编程

1.函数模板：一个独立于类型的函数，可以作为一种方式，产生函数的特定类型版本
2.类模板：使用类模板必须为模板形参显示指定实参，使用函数模板，编译器会根据实参类型推断形参，不用特意指定；
3.template是一个声明模板的关键字，类型参数一般用T这样的标识符来代表一个虚拟的类型，当使用函数模板时，会将类型参数具体化。
4.模板类型参数可以用typename 或者class 来修饰
5.模板编程中还可以在类型形参列表中定义非类型形参，这时非类型形参会被当成常量
6.函数模板可以定义函数指针并予以赋值
7.模板编译模型:由于要进行实例化，编译器必须能够访问定义模板的源代码；编译器提供了两种模型; a. 包含模型: incldue"xx.cc"到头文件中 b. 分别编译模型：export "xxx";代码中常见xx.hpp
8.普通类也能定义模板函数成员，称为成员模板，不能为虚；
9.非类型模板实参必须是编译时常量表达式
10.类模板可以声明static成员；?????实例化时会不会有几个相同的static- 类型不同，当然static函数也不同 函数--会实例化出不同的static 函数
11.句柄类的定义与使用？？
12.模板特化：
    函数模板的特化：当函数模板需要对某些类型进行特别处理，称为函数模板的特化
    template <> bool IsEqual(char* t1, char* t2) // 函数模板特化
    类模板的特化：当类模板内需要对某些类型进行特别处理时，使用类模板的特化
    template<>class compare<char *> //特化(char*)
13.模板与函数重载？？
14.总结：
    


