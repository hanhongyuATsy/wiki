++ 15.面向对象编程与泛型编程

1.面向对象的三个基本概念：封装（数据抽象），继承，多态（动态绑定）
2.动态绑定：绑定的是对象的动态类型，对函数的调用在运行时确定；
    两个条件：1.通过基类的引用（或指针）2.调用虚函数时（virtual）
3.静态绑定：绑定的是对象的静态类型，发生在编译期。
4.访问控制：
    1.private成员只能由基类的成员和友元访问；
    2.派生类对基类的public和private成员的访问权限与程序中任意其他部分一样
    3.protected成员可以被派生类对象访问但不能被该类型普通用户访问
5.覆盖虚函数机制：派生类虚函数调用基类版本时，必须显示使用作用域操作符。
6.虚函数的默认实参？？？
7.接口继承与实现继承： 接口继承，继承后对象可以访问基类接口，实现继承，继承后，无法访问基类的接口，只能使用基类接口的实现。
8.友元关系不继承；静态成员既可以用作用域操作符访问也可以用点或箭头访问
9.转换与继承：
    1.子类对象传给接受基类引用的函数--将子类对象转换为基类类型的引用
    2.子类对象传给接受基类类型对象的函数--将子类对象对基类对象进行初始化或赋值
9.派生类构造函数只能初始化自己的成员，不能初始化继承过来的成员，可以将基类构造包含在初始化列表中对基类进行初始化。
10.一个类只能初始化自己的直接子类
11.声明一个包含派生列表的类(而不实现)是错误的：class item: public base;
12.如果定义了子类的复制构造则一定要显示调用基类赋值构造函数。否则会出现 子类成员是被复制对象副本，而基类成员却未初始化。
13. 析构函数无论如何总是会调用父类的析构函数。析构函数运行顺序和构造函数相反，总是先运行子类析构函数再运行父类析构函数
14. 继承层次的根类要定义一个虚析构函数
15. 构造或析构中调用虚函数的动态绑定：构造或析构期间的对象类型对虚函数绑定有影响；构造或析构期间对象不完整，所以类型不确定。
16. 派生类的函数与基类的函数同名，但是参数列表有所差异。此时，不论有无virtual关键字，基类的函数在派生类中将被隐藏。此处子类和基类无法构成重载，而是隐藏，可以使用using关键字声明，而取消隐藏
17. 拥有纯虚函数的类无法定义对象，但可以定义指针或引用
18. 容器与继承：
    容器对象可以定义成存放基类对象，但可以给容器加入子类对象，这时候子类会被转换成基类对象，或者说基类部分会被系统删除。
    可以定义基类指针或引用类型容器，再增加子类指针活引用，这时候会更具实际内容不同执行不同代码（动态绑定）
19.句柄类，存储和管理基类指针
20.C++ 中定义继承层次接口的句柄类很常见，这些类分配并管理指向继承层次中对象的指针，使用户在无需处理指针的情况下获得动态行为











